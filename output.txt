============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.2, pluggy-1.6.0 -- /home/basitdev/Me/StudioProjects/VoiceNoteAPI/venv/bin/python
cachedir: .pytest_cache
rootdir: /home/basitdev/Me/StudioProjects/VoiceNoteAPI
configfile: pytest.ini
plugins: asyncio-1.3.0, locust-2.43.1, anyio-4.12.1
asyncio: mode=Mode.AUTO, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 4 items

tests/enterprise/test_b2b_oauth.py::test_list_integrations_empty ERROR   [ 25%]
tests/enterprise/test_b2b_oauth.py::test_connect_google ERROR            [ 50%]
tests/enterprise/test_b2b_oauth.py::test_connect_notion ERROR            [ 75%]
tests/enterprise/test_b2b_oauth.py::test_disconnect_integration ERROR    [100%]

==================================== ERRORS ====================================
________________ ERROR at setup of test_list_integrations_empty ________________

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394360>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        # Starts customization
        response_awaited = False
        async with AsyncExitStack() as request_stack:
            scope["fastapi_inner_astack"] = request_stack
            async with AsyncExitStack() as function_stack:
                scope["fastapi_function_astack"] = function_stack
>               response = await f(request)
                           ^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/fastapi/routing.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2d3a1070>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        file_stack = request.scope.get("fastapi_middleware_astack")
        assert isinstance(file_stack, AsyncExitStack), (
            "fastapi_middleware_astack not found in request scope"
        )
    
        # Extract endpoint context for error messages
        endpoint_ctx = (
            _extract_endpoint_context(dependant.call)
            if dependant.call
            else EndpointContext()
        )
    
        if dependant.path:
            # For mounted sub-apps, include the mount path prefix
            mount_path = request.scope.get("root_path", "").rstrip("/")
            endpoint_ctx["path"] = f"{request.method} {mount_path}{dependant.path}"
    
        # Read body and auto-close files
        try:
            body: Any = None
            if body_field:
                if is_body_form:
                    body = await request.form()
                    file_stack.push_async_callback(body.close)
                else:
                    body_bytes = await request.body()
                    if body_bytes:
                        json_body: Any = Undefined
                        content_type_value = request.headers.get("content-type")
                        if not content_type_value:
                            json_body = await request.json()
                        else:
                            message = email.message.Message()
                            message["content-type"] = content_type_value
                            if message.get_content_maintype() == "application":
                                subtype = message.get_content_subtype()
                                if subtype == "json" or subtype.endswith("+json"):
                                    json_body = await request.json()
                        if json_body != Undefined:
                            body = json_body
                        else:
                            body = body_bytes
        except json.JSONDecodeError as e:
            validation_error = RequestValidationError(
                [
                    {
                        "type": "json_invalid",
                        "loc": ("body", e.pos),
                        "msg": "JSON decode error",
                        "input": {},
                        "ctx": {"error": e.msg},
                    }
                ],
                body=e.doc,
                endpoint_ctx=endpoint_ctx,
            )
            raise validation_error from e
        except HTTPException:
            # If a middleware raises an HTTPException, it should be raised again
            raise
        except Exception as e:
            http_error = HTTPException(
                status_code=400, detail="There was an error parsing the body"
            )
            raise http_error from e
    
        # Solve dependencies and run path operation function, auto-closing dependencies
        errors: list[Any] = []
        async_exit_stack = request.scope.get("fastapi_inner_astack")
        assert isinstance(async_exit_stack, AsyncExitStack), (
            "fastapi_inner_astack not found in request scope"
        )
        solved_result = await solve_dependencies(
            request=request,
            dependant=dependant,
            body=body,
            dependency_overrides_provider=dependency_overrides_provider,
            async_exit_stack=async_exit_stack,
            embed_body_fields=embed_body_fields,
        )
        errors = solved_result.errors
        if not errors:
            raw_response = await run_endpoint_function(
                dependant=dependant,
                values=solved_result.values,
                is_coroutine=is_coroutine,
            )
            if isinstance(raw_response, Response):
                if raw_response.background is None:
                    raw_response.background = solved_result.background_tasks
                response = raw_response
            else:
                response_args: dict[str, Any] = {
                    "background": solved_result.background_tasks
                }
                # If status_code was set, use it, otherwise use the default from the
                # response class, in the case of redirect it's 307
                current_status_code = (
                    status_code if status_code else solved_result.response.status_code
                )
                if current_status_code is not None:
                    response_args["status_code"] = current_status_code
                if solved_result.response.status_code:
                    response_args["status_code"] = solved_result.response.status_code
                content = await serialize_response(
                    field=response_field,
                    response_content=raw_response,
                    include=response_model_include,
                    exclude=response_model_exclude,
                    by_alias=response_model_by_alias,
                    exclude_unset=response_model_exclude_unset,
                    exclude_defaults=response_model_exclude_defaults,
                    exclude_none=response_model_exclude_none,
                    is_coroutine=is_coroutine,
                    endpoint_ctx=endpoint_ctx,
                )
                response = actual_response_class(content, **response_args)
                if not is_body_allowed_for_status_code(response.status_code):
                    response.body = b""
                response.headers.raw.extend(solved_result.response.headers.raw)
        if errors:
            validation_error = RequestValidationError(
                errors, body=body, endpoint_ctx=endpoint_ctx
            )
>           raise validation_error
E           fastapi.exceptions.RequestValidationError: 1 validation error:
E             {'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePassword123%21'}
E           
E             File "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/venv/lib/python3.12/site-packages/slowapi/extension.py", line 109, in login_user
E               POST /api/v1/users/login

venv/lib/python3.12/site-packages/fastapi/routing.py:397: RequestValidationError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x73ce2de86cc0>

    @pytest.fixture
    def auth_context(client):
        """Get authentication context (token and user info) for tests"""
        timestamp = int(1000 * time.time()) # increased resolution
        email = f"test_oauth_{timestamp}@example.com"
        password = "SecurePassword123!"
    
        # Register
        client.post("/api/v1/users/register", json={
            "email": email,
            "password": password,
            "name": f"Test OAuth User {timestamp}",
            "device_id": f"test-device-{timestamp}",
            "device_model": "Pytest CI"
        })
    
        # Login
>       login_response = client.post("/api/v1/users/login", data={
            "username": email,
            "password": password
        })

tests/enterprise/test_b2b_oauth.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
url = '/api/v1/users/login'

    def post(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
>       return super().post(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
url = '/api/v1/users/login'

    def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/httpx/_client.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(  # type: ignore[override]
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        if timeout is not httpx.USE_CLIENT_DEFAULT:
            warnings.warn(
                "You should not use the 'timeout' argument with the TestClient. "
                "See https://github.com/Kludex/starlette/issues/1108 for more information.",
                DeprecationWarning,
            )
        url = self._merge_url(url)
>       return super().request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = client.send(request, ...)
        ```
    
        See `Client.build_request()`, `Client.send()` and
        [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
        if cookies is not None:
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `Client.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

venv/lib/python3.12/site-packages/httpx/_client.py:914: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
auth = <httpx.Auth object at 0x73ce2d377fe0>, follow_redirects = True
history = []

    def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.sync_auth_flow(request)
        try:
            request = next(auth_flow)
    
            while True:
>               response = self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

venv/lib/python3.12/site-packages/httpx/_client.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
follow_redirects = True, history = []

    def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                hook(request)
    
>           response = self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2de86cc0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, SyncByteStream):
            raise RuntimeError(
                "Attempted to send an async request with a sync Client instance."
            )
    
        with request_context(request=request):
>           response = transport.handle_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2ddf08f0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
                portal.call(self.app, scope, receive, send)
        except BaseException as exc:
            if self.raise_server_exceptions:
>               raise exc

venv/lib/python3.12/site-packages/starlette/testclient.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2ddf08f0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
>               portal.call(self.app, scope, receive, send)

venv/lib/python3.12/site-packages/starlette/testclient.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2dc24200>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce2ddbab60>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce680a85e0>)

    def call(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        *args: Unpack[PosArgsT],
    ) -> T_Retval:
        """
        Call the given function in the event loop thread.
    
        If the callable returns a coroutine object, it is awaited on.
    
        :param func: any callable
        :raises RuntimeError: if the portal is not running or if this method is called
            from within the event loop thread
    
        """
>       return cast(T_Retval, self.start_task_soon(func, *args).result())
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None, timeout = None

    def result(self, timeout=None):
        """Return the result of the call that the future represents.
    
        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.
    
        Returns:
            The result of the call that the future represents.
    
        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
        try:
            with self._condition:
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
                    return self.__get_result()
    
                self._condition.wait(timeout)
    
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
>                   return self.__get_result()
                           ^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/concurrent/futures/_base.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None

    def __get_result(self):
        if self._exception:
            try:
>               raise self._exception

/usr/lib/python3.12/concurrent/futures/_base.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2dc24200>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce2ddbab60>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce680a85e0>)
kwargs = {}, future = <Future at 0x73ce2dc25910 state=finished raised TypeError>

    async def _call_func(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        args: tuple[Unpack[PosArgsT]],
        kwargs: dict[str, Any],
        future: Future[T_Retval],
    ) -> None:
        def callback(f: Future[T_Retval]) -> None:
            if f.cancelled():
                if self._event_loop_thread_id == get_ident():
                    scope.cancel("the future was cancelled")
                elif self._event_loop_thread_id is not None:
                    self.call(scope.cancel, "the future was cancelled")
    
        try:
            retval_or_awaitable = func(*args, **kwargs)
            if isawaitable(retval_or_awaitable):
                with CancelScope() as scope:
                    future.add_done_callback(callback)
>                   retval = await retval_or_awaitable
                             ^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2ddbab60>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce680a85e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/applications.py:1135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2ddbab60>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce680a85e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/applications.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2ddbab60>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce680a85e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2ddbab60>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce680a85e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2ddbab60>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2dc0d9e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
>       with recv_stream, send_stream, collapse_excgroups():

venv/lib/python3.12/site-packages/starlette/middleware/base.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x73ce2d3a0470>
typ = <class 'ExceptionGroup'>
value = ExceptionGroup('unhandled errors in a TaskGroup', [TypeError('Object of type bytes is not JSON serializable')])
traceback = <traceback object at 0x73ce2d3ac700>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                try:
                    raise RuntimeError("generator didn't stop")
                finally:
                    self.gen.close()
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(value)

/usr/lib/python3.12/contextlib.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextmanager
    def collapse_excgroups() -> Generator[None, None, None]:
        try:
            yield
        except BaseException as exc:
            if has_exceptiongroups:  # pragma: no cover
                while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:
                    exc = exc.exceptions[0]
    
>           raise exc

venv/lib/python3.12/site-packages/starlette/_utils.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2ddbab60>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2dc0d9e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
        with recv_stream, send_stream, collapse_excgroups():
            async with anyio.create_task_group() as task_group:
>               response = await self.dispatch_func(request, call_next)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/middleware/base.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
request = <starlette.middleware.base._CachedRequest object at 0x73ce2d3a0110>
call_next = <function BaseHTTPMiddleware.__call__.<locals>.call_next at 0x73ce2dc0d580>

    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
    
        # Pass through check for health/metrics endpoints
        if request.url.path in ["/", "/health", "/metrics", "/docs", "/openapi.json"]:
            return await call_next(request)
    
        # 1. Capture User ID and Geolocation
        user_id = getattr(request.state, "user_id", None)
        if not user_id:
            user_id = request.headers.get("X-User-ID", "anonymous")
    
        gps_header = request.headers.get("x-gps-coords") or request.headers.get("X-GPS-Coords")
    
        corporate_wallet_id = None
    
        # Token extraction for early auth
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                user_id = payload.get("sub")
                request.state.user_id = user_id
            except Exception as e:
                JLogger.debug("Middleware: Token decode failed", error=str(e))
    
        # COST ESTIMATION
        cost_map = {
            "/api/v1/notes": 1,
            "/api/v1/transcribe": 10,
            "/api/v1/ai/analyze": 5,
        }
        estimated_cost = 0
        for path, cost in cost_map.items():
            if path in request.url.path:
                estimated_cost = cost
                break
    
        db = None
        try:
            if user_id != "anonymous" and (gps_header or estimated_cost > 0):
                db = SessionLocal()
                user = db.query(models.User).filter(models.User.id == user_id).first()
                request.state.user = user
    
                if user and user.org_id and gps_header:
                    try:
                        lat_str, lon_str = gps_header.split(",")
                        user_lat, user_lon = float(lat_str), float(lon_str)
                        locations = (
                            db.query(models.WorkLocation)
                            .filter(models.WorkLocation.org_id == user.org_id)
                            .all()
                        )
                        for loc in locations:
                            dist = calculate_distance(user_lat, user_lon, loc.latitude, loc.longitude)
                            # Use config minimum radius if loc.radius is too small (GPS Drift)
                            effective_radius = max(loc.radius, location_config.DEFAULT_GEOFENCE_RADIUS)
                            if dist <= effective_radius:
                                org = db.query(models.Organization).filter(models.Organization.id == user.org_id).first()
                                if org:
                                    corporate_wallet_id = org.corporate_wallet_id
                                    JLogger.info("Middleware: Within geofence, corporate wallet selected", wallet=corporate_wallet_id)
                                break
                    except Exception as e:
                        JLogger.error("Middleware: Geofence error", error=str(e))
    
                if estimated_cost > 0:
                    # Premium users get free notes processing
                    if user and user.tier == models.SubscriptionTier.PREMIUM and "/api/v1/notes" in request.url.path:
                        estimated_cost = 0
    
                    if estimated_cost > 0:
                        billing = BillingService(db)
                        target_wallet = corporate_wallet_id or user_id
                        if not billing.check_balance(target_wallet, estimated_cost, for_update=True):
                            return JSONResponse(
                                status_code=402,
                                content={"detail": f"Payment Required: balance depleted."},
                            )
    
>           response = await call_next(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

app/api/middleware/usage.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.middleware.base._CachedRequest object at 0x73ce2d3a0110>

    async def call_next(request: Request) -> Response:
        async def receive_or_disconnect() -> Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(wrapped_receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def send_no_error(message: Message) -> None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -> None:
            nonlocal app_exc
    
            with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(coro)
    
        try:
            message = await recv_stream.receive()
            info = message.get("info", None)
            if message["type"] == "http.response.debug" and info is not None:
                message = await recv_stream.receive()
        except anyio.EndOfStream:
            if app_exc is not None:
                nonlocal exception_already_raised
                exception_already_raised = True
                # Prevent `anyio.EndOfStream` from polluting app exception context.
                # If both cause and context are None then the context is suppressed
                # and `anyio.EndOfStream` is not present in the exception traceback.
                # If exception cause is not None then it is propagated with
                # reraising here.
                # If exception has no cause but has context set then the context is
                # propagated as a cause with the reraise. This is necessary in order
                # to prevent `anyio.EndOfStream` from polluting the exception
                # context.
>               raise app_exc from app_exc.__cause__ or app_exc.__context__

venv/lib/python3.12/site-packages/starlette/middleware/base.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def coro() -> None:
        nonlocal app_exc
    
        with send_stream:
            try:
>               await self.app(scope, receive_or_disconnect, send_no_error)

venv/lib/python3.12/site-packages/starlette/middleware/base.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2d394b80>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
            await self.app(scope, receive, send_wrapper)
        except Exception as exc:
>           raise exc

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2d394b80>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
>           await self.app(scope, receive, send_wrapper)

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipMiddleware object at 0x73ce2e0dda00>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2d3940e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":  # pragma: no cover
            await self.app(scope, receive, send)
            return
    
        headers = Headers(scope=scope)
        responder: ASGIApp
        if "gzip" in headers.get("Accept-Encoding", ""):
            responder = GZipResponder(self.app, self.minimum_size, compresslevel=self.compresslevel)
        else:
            responder = IdentityResponder(self.app, self.minimum_size)
    
>       await responder(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2d3a0e00>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2d3940e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        with self.gzip_buffer, self.gzip_file:
>           await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2d3a0e00>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2d3940e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        self.send = send
>       await self.app(scope, receive, self.send_with_compression)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x73ce2ddf38c0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2d3a0e00>>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2d3a0e00>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2d3a0e00>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.middleware.asyncexitstack.AsyncExitStackMiddleware object at 0x73ce2ddf3890>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        async with AsyncExitStack() as stack:
            scope[self.context_name] = stack
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = APIRoute(path='/api/v1/users/login', name='login_user', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse("Method Not Allowed", status_code=405, headers=headers)
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            # Starts customization
            response_awaited = False
            async with AsyncExitStack() as request_stack:
                scope["fastapi_inner_astack"] = request_stack
                async with AsyncExitStack() as function_stack:
                    scope["fastapi_function_astack"] = function_stack
                    response = await f(request)
                await response(scope, receive, send)
                # Continues customization
                response_awaited = True
            if not response_awaited:
                raise FastAPIError(
                    "Response not awaited. There's a high chance that the "
                    "application code is raising an exception and a dependency with yield "
                    "has a block with a bare except, or a block with except Exception, "
                    "and is not raising the exception again. Read more about it in the "
                    "docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except"
                )
    
        # Same as in Starlette
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/routing.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2d35a660>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2d394ea0>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
                raise exc
    
            if response_started:
                raise RuntimeError("Caught handled exception, but response already started.") from exc
    
            if is_async_callable(handler):
>               response = await handler(conn, exc)
                           ^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2d3a1070>
exc = RequestValidationError([{'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary...t to extract fields from', 'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePassword123%21'}])

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        """Standardize Pydantic validation errors."""
>       return JSONResponse(
            status_code=400,
            content={
                "error": "Validation failed",
                "code": "VALIDATION_ERROR",
                "detail": exc.errors()
            },
        )

app/main.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2d377f50>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
>       super().__init__(content, status_code, headers, media_type, background)

venv/lib/python3.12/site-packages/starlette/responses.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2d377f50>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
>       self.body = self.render(content)
                    ^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/responses.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2d377f50>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def render(self, content: Any) -> bytes:
>       return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")

venv/lib/python3.12/site-packages/starlette/responses.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
skipkeys = False, ensure_ascii = False, check_circular = True, allow_nan = False
cls = <class 'json.encoder.JSONEncoder'>, indent = None, separators = (',', ':')
default = None

    def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
            allow_nan=True, cls=None, indent=None, separators=None,
            default=None, sort_keys=False, **kw):
        """Serialize ``obj`` to a JSON formatted ``str``.
    
        If ``skipkeys`` is true then ``dict`` keys that are not basic types
        (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
        instead of raising a ``TypeError``.
    
        If ``ensure_ascii`` is false, then the return value can contain non-ASCII
        characters if they appear in strings contained in ``obj``. Otherwise, all
        such characters are escaped in JSON strings.
    
        If ``check_circular`` is false, then the circular reference check
        for container types will be skipped and a circular reference will
        result in an ``RecursionError`` (or worse).
    
        If ``allow_nan`` is false, then it will be a ``ValueError`` to
        serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
        strict compliance of the JSON specification, instead of using the
        JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).
    
        If ``indent`` is a non-negative integer, then JSON array elements and
        object members will be pretty-printed with that indent level. An indent
        level of 0 will only insert newlines. ``None`` is the most compact
        representation.
    
        If specified, ``separators`` should be an ``(item_separator, key_separator)``
        tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
        ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
        you should specify ``(',', ':')`` to eliminate whitespace.
    
        ``default(obj)`` is a function that should return a serializable version
        of obj or raise TypeError. The default simply raises TypeError.
    
        If *sort_keys* is true (default: ``False``), then the output of
        dictionaries will be sorted by key.
    
        To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
        ``.default()`` method to serialize additional types), specify it with
        the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
    
        """
        # cached encoder
        if (not skipkeys and ensure_ascii and
            check_circular and allow_nan and
            cls is None and indent is None and separators is None and
            default is None and not sort_keys and not kw):
            return _default_encoder.encode(obj)
        if cls is None:
            cls = JSONEncoder
        return cls(
            skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, allow_nan=allow_nan, indent=indent,
            separators=separators, default=default, sort_keys=sort_keys,
>           **kw).encode(obj)
                  ^^^^^^^^^^^

/usr/lib/python3.12/json/__init__.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2d3a1460>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.
    
        >>> from json.encoder import JSONEncoder
        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'
    
        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, str):
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
>       chunks = self.iterencode(o, _one_shot=True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2d3a1460>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092536291%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
_one_shot = True

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.
    
        For example::
    
            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)
    
        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
    
        def floatstr(o, allow_nan=self.allow_nan,
                _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
            # Check for specials.  Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on the
            # internals.
    
            if o != o:
                text = 'NaN'
            elif o == _inf:
                text = 'Infinity'
            elif o == _neginf:
                text = '-Infinity'
            else:
                return _repr(o)
    
            if not allow_nan:
                raise ValueError(
                    "Out of range float values are not JSON compliant: " +
                    repr(o))
    
            return text
    
    
        if (_one_shot and c_make_encoder is not None
                and self.indent is None):
            _iterencode = c_make_encoder(
                markers, self.default, _encoder, self.indent,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, self.allow_nan)
        else:
            _iterencode = _make_iterencode(
                markers, self.default, _encoder, self.indent, floatstr,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, _one_shot)
>       return _iterencode(o, 0)
               ^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2d3a1460>
o = b'username=test_oauth_1771092536291%40example.com&password=SecurePassword123%21'

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type bytes is not JSON serializable

/usr/lib/python3.12/json/encoder.py:180: TypeError
---------------------------- Captured stdout setup -----------------------------
DEBUG AUTH: create_access_token return type: <class 'str'> value: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5NDJkMGU5MC1lYTAxLTQ5M2UtOTkwZC03OGIwOTA3YTZjOGEiLCJleHAiOjE3NzEwOTYxMzYsInR5cGUiOiJhY2Nlc3MifQ._je0YQUjTK4sGt7kBCKyx28Kt9ZrjGWjM6plByPzfsY
{"timestamp": "2026-02-14T18:08:56.734970+00:00", "level": "CRITICAL", "logger": "VoiceNote", "message": "Unhandled exception: Object of type bytes is not JSON serializable", "filename": "main.py", "funcName": "generic_exception_handler", "lineno": 126, "pathname": "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/app/main.py", "traceback": true}
------------------------------ Captured log setup ------------------------------
CRITICAL VoiceNote:main.py:126 Unhandled exception: Object of type bytes is not JSON serializable
____________________ ERROR at setup of test_connect_google _____________________

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd80720>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        # Starts customization
        response_awaited = False
        async with AsyncExitStack() as request_stack:
            scope["fastapi_inner_astack"] = request_stack
            async with AsyncExitStack() as function_stack:
                scope["fastapi_function_astack"] = function_stack
>               response = await f(request)
                           ^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/fastapi/routing.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2cd79370>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        file_stack = request.scope.get("fastapi_middleware_astack")
        assert isinstance(file_stack, AsyncExitStack), (
            "fastapi_middleware_astack not found in request scope"
        )
    
        # Extract endpoint context for error messages
        endpoint_ctx = (
            _extract_endpoint_context(dependant.call)
            if dependant.call
            else EndpointContext()
        )
    
        if dependant.path:
            # For mounted sub-apps, include the mount path prefix
            mount_path = request.scope.get("root_path", "").rstrip("/")
            endpoint_ctx["path"] = f"{request.method} {mount_path}{dependant.path}"
    
        # Read body and auto-close files
        try:
            body: Any = None
            if body_field:
                if is_body_form:
                    body = await request.form()
                    file_stack.push_async_callback(body.close)
                else:
                    body_bytes = await request.body()
                    if body_bytes:
                        json_body: Any = Undefined
                        content_type_value = request.headers.get("content-type")
                        if not content_type_value:
                            json_body = await request.json()
                        else:
                            message = email.message.Message()
                            message["content-type"] = content_type_value
                            if message.get_content_maintype() == "application":
                                subtype = message.get_content_subtype()
                                if subtype == "json" or subtype.endswith("+json"):
                                    json_body = await request.json()
                        if json_body != Undefined:
                            body = json_body
                        else:
                            body = body_bytes
        except json.JSONDecodeError as e:
            validation_error = RequestValidationError(
                [
                    {
                        "type": "json_invalid",
                        "loc": ("body", e.pos),
                        "msg": "JSON decode error",
                        "input": {},
                        "ctx": {"error": e.msg},
                    }
                ],
                body=e.doc,
                endpoint_ctx=endpoint_ctx,
            )
            raise validation_error from e
        except HTTPException:
            # If a middleware raises an HTTPException, it should be raised again
            raise
        except Exception as e:
            http_error = HTTPException(
                status_code=400, detail="There was an error parsing the body"
            )
            raise http_error from e
    
        # Solve dependencies and run path operation function, auto-closing dependencies
        errors: list[Any] = []
        async_exit_stack = request.scope.get("fastapi_inner_astack")
        assert isinstance(async_exit_stack, AsyncExitStack), (
            "fastapi_inner_astack not found in request scope"
        )
        solved_result = await solve_dependencies(
            request=request,
            dependant=dependant,
            body=body,
            dependency_overrides_provider=dependency_overrides_provider,
            async_exit_stack=async_exit_stack,
            embed_body_fields=embed_body_fields,
        )
        errors = solved_result.errors
        if not errors:
            raw_response = await run_endpoint_function(
                dependant=dependant,
                values=solved_result.values,
                is_coroutine=is_coroutine,
            )
            if isinstance(raw_response, Response):
                if raw_response.background is None:
                    raw_response.background = solved_result.background_tasks
                response = raw_response
            else:
                response_args: dict[str, Any] = {
                    "background": solved_result.background_tasks
                }
                # If status_code was set, use it, otherwise use the default from the
                # response class, in the case of redirect it's 307
                current_status_code = (
                    status_code if status_code else solved_result.response.status_code
                )
                if current_status_code is not None:
                    response_args["status_code"] = current_status_code
                if solved_result.response.status_code:
                    response_args["status_code"] = solved_result.response.status_code
                content = await serialize_response(
                    field=response_field,
                    response_content=raw_response,
                    include=response_model_include,
                    exclude=response_model_exclude,
                    by_alias=response_model_by_alias,
                    exclude_unset=response_model_exclude_unset,
                    exclude_defaults=response_model_exclude_defaults,
                    exclude_none=response_model_exclude_none,
                    is_coroutine=is_coroutine,
                    endpoint_ctx=endpoint_ctx,
                )
                response = actual_response_class(content, **response_args)
                if not is_body_allowed_for_status_code(response.status_code):
                    response.body = b""
                response.headers.raw.extend(solved_result.response.headers.raw)
        if errors:
            validation_error = RequestValidationError(
                errors, body=body, endpoint_ctx=endpoint_ctx
            )
>           raise validation_error
E           fastapi.exceptions.RequestValidationError: 1 validation error:
E             {'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePassword123%21'}
E           
E             File "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/venv/lib/python3.12/site-packages/slowapi/extension.py", line 109, in login_user
E               POST /api/v1/users/login

venv/lib/python3.12/site-packages/fastapi/routing.py:397: RequestValidationError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>

    @pytest.fixture
    def auth_context(client):
        """Get authentication context (token and user info) for tests"""
        timestamp = int(1000 * time.time()) # increased resolution
        email = f"test_oauth_{timestamp}@example.com"
        password = "SecurePassword123!"
    
        # Register
        client.post("/api/v1/users/register", json={
            "email": email,
            "password": password,
            "name": f"Test OAuth User {timestamp}",
            "device_id": f"test-device-{timestamp}",
            "device_model": "Pytest CI"
        })
    
        # Login
>       login_response = client.post("/api/v1/users/login", data={
            "username": email,
            "password": password
        })

tests/enterprise/test_b2b_oauth.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
url = '/api/v1/users/login'

    def post(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
>       return super().post(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
url = '/api/v1/users/login'

    def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/httpx/_client.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(  # type: ignore[override]
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        if timeout is not httpx.USE_CLIENT_DEFAULT:
            warnings.warn(
                "You should not use the 'timeout' argument with the TestClient. "
                "See https://github.com/Kludex/starlette/issues/1108 for more information.",
                DeprecationWarning,
            )
        url = self._merge_url(url)
>       return super().request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = client.send(request, ...)
        ```
    
        See `Client.build_request()`, `Client.send()` and
        [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
        if cookies is not None:
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `Client.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

venv/lib/python3.12/site-packages/httpx/_client.py:914: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
auth = <httpx.Auth object at 0x73ce2cdbe660>, follow_redirects = True
history = []

    def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.sync_auth_flow(request)
        try:
            request = next(auth_flow)
    
            while True:
>               response = self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

venv/lib/python3.12/site-packages/httpx/_client.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
follow_redirects = True, history = []

    def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                hook(request)
    
>           response = self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdbdc40>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, SyncByteStream):
            raise RuntimeError(
                "Attempted to send an async request with a sync Client instance."
            )
    
        with request_context(request=request):
>           response = transport.handle_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2cdbdee0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
                portal.call(self.app, scope, receive, send)
        except BaseException as exc:
            if self.raise_server_exceptions:
>               raise exc

venv/lib/python3.12/site-packages/starlette/testclient.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2cdbdee0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
>               portal.call(self.app, scope, receive, send)

venv/lib/python3.12/site-packages/starlette/testclient.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2cd78f80>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce6725dd00>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2d227e20>)

    def call(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        *args: Unpack[PosArgsT],
    ) -> T_Retval:
        """
        Call the given function in the event loop thread.
    
        If the callable returns a coroutine object, it is awaited on.
    
        :param func: any callable
        :raises RuntimeError: if the portal is not running or if this method is called
            from within the event loop thread
    
        """
>       return cast(T_Retval, self.start_task_soon(func, *args).result())
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None, timeout = None

    def result(self, timeout=None):
        """Return the result of the call that the future represents.
    
        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.
    
        Returns:
            The result of the call that the future represents.
    
        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
        try:
            with self._condition:
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
                    return self.__get_result()
    
                self._condition.wait(timeout)
    
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
>                   return self.__get_result()
                           ^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/concurrent/futures/_base.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None

    def __get_result(self):
        if self._exception:
            try:
>               raise self._exception

/usr/lib/python3.12/concurrent/futures/_base.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2cd78f80>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce6725dd00>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2d227e20>)
kwargs = {}, future = <Future at 0x73ce2cd78f50 state=finished raised TypeError>

    async def _call_func(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        args: tuple[Unpack[PosArgsT]],
        kwargs: dict[str, Any],
        future: Future[T_Retval],
    ) -> None:
        def callback(f: Future[T_Retval]) -> None:
            if f.cancelled():
                if self._event_loop_thread_id == get_ident():
                    scope.cancel("the future was cancelled")
                elif self._event_loop_thread_id is not None:
                    self.call(scope.cancel, "the future was cancelled")
    
        try:
            retval_or_awaitable = func(*args, **kwargs)
            if isawaitable(retval_or_awaitable):
                with CancelScope() as scope:
                    future.add_done_callback(callback)
>                   retval = await retval_or_awaitable
                             ^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce6725dd00>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2d227e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/applications.py:1135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce6725dd00>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2d227e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/applications.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce6725dd00>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2d227e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce6725dd00>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2d227e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce6725dd00>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2c9c77e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
>       with recv_stream, send_stream, collapse_excgroups():

venv/lib/python3.12/site-packages/starlette/middleware/base.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x73ce2cd782f0>
typ = <class 'ExceptionGroup'>
value = ExceptionGroup('unhandled errors in a TaskGroup', [TypeError('Object of type bytes is not JSON serializable')])
traceback = <traceback object at 0x73ce2c2063c0>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                try:
                    raise RuntimeError("generator didn't stop")
                finally:
                    self.gen.close()
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(value)

/usr/lib/python3.12/contextlib.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextmanager
    def collapse_excgroups() -> Generator[None, None, None]:
        try:
            yield
        except BaseException as exc:
            if has_exceptiongroups:  # pragma: no cover
                while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:
                    exc = exc.exceptions[0]
    
>           raise exc

venv/lib/python3.12/site-packages/starlette/_utils.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce6725dd00>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2c9c77e0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
        with recv_stream, send_stream, collapse_excgroups():
            async with anyio.create_task_group() as task_group:
>               response = await self.dispatch_func(request, call_next)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/middleware/base.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
request = <starlette.middleware.base._CachedRequest object at 0x73ce2cd78860>
call_next = <function BaseHTTPMiddleware.__call__.<locals>.call_next at 0x73ce2c9c7740>

    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
    
        # Pass through check for health/metrics endpoints
        if request.url.path in ["/", "/health", "/metrics", "/docs", "/openapi.json"]:
            return await call_next(request)
    
        # 1. Capture User ID and Geolocation
        user_id = getattr(request.state, "user_id", None)
        if not user_id:
            user_id = request.headers.get("X-User-ID", "anonymous")
    
        gps_header = request.headers.get("x-gps-coords") or request.headers.get("X-GPS-Coords")
    
        corporate_wallet_id = None
    
        # Token extraction for early auth
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                user_id = payload.get("sub")
                request.state.user_id = user_id
            except Exception as e:
                JLogger.debug("Middleware: Token decode failed", error=str(e))
    
        # COST ESTIMATION
        cost_map = {
            "/api/v1/notes": 1,
            "/api/v1/transcribe": 10,
            "/api/v1/ai/analyze": 5,
        }
        estimated_cost = 0
        for path, cost in cost_map.items():
            if path in request.url.path:
                estimated_cost = cost
                break
    
        db = None
        try:
            if user_id != "anonymous" and (gps_header or estimated_cost > 0):
                db = SessionLocal()
                user = db.query(models.User).filter(models.User.id == user_id).first()
                request.state.user = user
    
                if user and user.org_id and gps_header:
                    try:
                        lat_str, lon_str = gps_header.split(",")
                        user_lat, user_lon = float(lat_str), float(lon_str)
                        locations = (
                            db.query(models.WorkLocation)
                            .filter(models.WorkLocation.org_id == user.org_id)
                            .all()
                        )
                        for loc in locations:
                            dist = calculate_distance(user_lat, user_lon, loc.latitude, loc.longitude)
                            # Use config minimum radius if loc.radius is too small (GPS Drift)
                            effective_radius = max(loc.radius, location_config.DEFAULT_GEOFENCE_RADIUS)
                            if dist <= effective_radius:
                                org = db.query(models.Organization).filter(models.Organization.id == user.org_id).first()
                                if org:
                                    corporate_wallet_id = org.corporate_wallet_id
                                    JLogger.info("Middleware: Within geofence, corporate wallet selected", wallet=corporate_wallet_id)
                                break
                    except Exception as e:
                        JLogger.error("Middleware: Geofence error", error=str(e))
    
                if estimated_cost > 0:
                    # Premium users get free notes processing
                    if user and user.tier == models.SubscriptionTier.PREMIUM and "/api/v1/notes" in request.url.path:
                        estimated_cost = 0
    
                    if estimated_cost > 0:
                        billing = BillingService(db)
                        target_wallet = corporate_wallet_id or user_id
                        if not billing.check_balance(target_wallet, estimated_cost, for_update=True):
                            return JSONResponse(
                                status_code=402,
                                content={"detail": f"Payment Required: balance depleted."},
                            )
    
>           response = await call_next(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

app/api/middleware/usage.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.middleware.base._CachedRequest object at 0x73ce2cd78860>

    async def call_next(request: Request) -> Response:
        async def receive_or_disconnect() -> Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(wrapped_receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def send_no_error(message: Message) -> None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -> None:
            nonlocal app_exc
    
            with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(coro)
    
        try:
            message = await recv_stream.receive()
            info = message.get("info", None)
            if message["type"] == "http.response.debug" and info is not None:
                message = await recv_stream.receive()
        except anyio.EndOfStream:
            if app_exc is not None:
                nonlocal exception_already_raised
                exception_already_raised = True
                # Prevent `anyio.EndOfStream` from polluting app exception context.
                # If both cause and context are None then the context is suppressed
                # and `anyio.EndOfStream` is not present in the exception traceback.
                # If exception cause is not None then it is propagated with
                # reraising here.
                # If exception has no cause but has context set then the context is
                # propagated as a cause with the reraise. This is necessary in order
                # to prevent `anyio.EndOfStream` from polluting the exception
                # context.
>               raise app_exc from app_exc.__cause__ or app_exc.__context__

venv/lib/python3.12/site-packages/starlette/middleware/base.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def coro() -> None:
        nonlocal app_exc
    
        with send_stream:
            try:
>               await self.app(scope, receive_or_disconnect, send_no_error)

venv/lib/python3.12/site-packages/starlette/middleware/base.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2c9c7380>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
            await self.app(scope, receive, send_wrapper)
        except Exception as exc:
>           raise exc

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2c9c7380>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
>           await self.app(scope, receive, send_wrapper)

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipMiddleware object at 0x73ce2e0dda00>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2c9c71a0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":  # pragma: no cover
            await self.app(scope, receive, send)
            return
    
        headers = Headers(scope=scope)
        responder: ASGIApp
        if "gzip" in headers.get("Accept-Encoding", ""):
            responder = GZipResponder(self.app, self.minimum_size, compresslevel=self.compresslevel)
        else:
            responder = IdentityResponder(self.app, self.minimum_size)
    
>       await responder(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2cd78ec0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2c9c71a0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        with self.gzip_buffer, self.gzip_file:
>           await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2cd78ec0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2c9c71a0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        self.send = send
>       await self.app(scope, receive, self.send_with_compression)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x73ce2ddf38c0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cd78ec0>>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cd78ec0>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cd78ec0>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.middleware.asyncexitstack.AsyncExitStackMiddleware object at 0x73ce2ddf3890>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        async with AsyncExitStack() as stack:
            scope[self.context_name] = stack
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = APIRoute(path='/api/v1/users/login', name='login_user', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse("Method Not Allowed", status_code=405, headers=headers)
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            # Starts customization
            response_awaited = False
            async with AsyncExitStack() as request_stack:
                scope["fastapi_inner_astack"] = request_stack
                async with AsyncExitStack() as function_stack:
                    scope["fastapi_function_astack"] = function_stack
                    response = await f(request)
                await response(scope, receive, send)
                # Continues customization
                response_awaited = True
            if not response_awaited:
                raise FastAPIError(
                    "Response not awaited. There's a high chance that the "
                    "application code is raising an exception and a dependency with yield "
                    "has a block with a bare except, or a block with except Exception, "
                    "and is not raising the exception again. Read more about it in the "
                    "docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except"
                )
    
        # Same as in Starlette
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/routing.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c9c72e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c9c7880>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
                raise exc
    
            if response_started:
                raise RuntimeError("Caught handled exception, but response already started.") from exc
    
            if is_async_callable(handler):
>               response = await handler(conn, exc)
                           ^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2cd79370>
exc = RequestValidationError([{'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary...t to extract fields from', 'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePassword123%21'}])

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        """Standardize Pydantic validation errors."""
>       return JSONResponse(
            status_code=400,
            content={
                "error": "Validation failed",
                "code": "VALIDATION_ERROR",
                "detail": exc.errors()
            },
        )

app/main.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cd797c0>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
>       super().__init__(content, status_code, headers, media_type, background)

venv/lib/python3.12/site-packages/starlette/responses.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cd797c0>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
>       self.body = self.render(content)
                    ^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/responses.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cd797c0>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def render(self, content: Any) -> bytes:
>       return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")

venv/lib/python3.12/site-packages/starlette/responses.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
skipkeys = False, ensure_ascii = False, check_circular = True, allow_nan = False
cls = <class 'json.encoder.JSONEncoder'>, indent = None, separators = (',', ':')
default = None

    def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
            allow_nan=True, cls=None, indent=None, separators=None,
            default=None, sort_keys=False, **kw):
        """Serialize ``obj`` to a JSON formatted ``str``.
    
        If ``skipkeys`` is true then ``dict`` keys that are not basic types
        (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
        instead of raising a ``TypeError``.
    
        If ``ensure_ascii`` is false, then the return value can contain non-ASCII
        characters if they appear in strings contained in ``obj``. Otherwise, all
        such characters are escaped in JSON strings.
    
        If ``check_circular`` is false, then the circular reference check
        for container types will be skipped and a circular reference will
        result in an ``RecursionError`` (or worse).
    
        If ``allow_nan`` is false, then it will be a ``ValueError`` to
        serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
        strict compliance of the JSON specification, instead of using the
        JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).
    
        If ``indent`` is a non-negative integer, then JSON array elements and
        object members will be pretty-printed with that indent level. An indent
        level of 0 will only insert newlines. ``None`` is the most compact
        representation.
    
        If specified, ``separators`` should be an ``(item_separator, key_separator)``
        tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
        ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
        you should specify ``(',', ':')`` to eliminate whitespace.
    
        ``default(obj)`` is a function that should return a serializable version
        of obj or raise TypeError. The default simply raises TypeError.
    
        If *sort_keys* is true (default: ``False``), then the output of
        dictionaries will be sorted by key.
    
        To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
        ``.default()`` method to serialize additional types), specify it with
        the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
    
        """
        # cached encoder
        if (not skipkeys and ensure_ascii and
            check_circular and allow_nan and
            cls is None and indent is None and separators is None and
            default is None and not sort_keys and not kw):
            return _default_encoder.encode(obj)
        if cls is None:
            cls = JSONEncoder
        return cls(
            skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, allow_nan=allow_nan, indent=indent,
            separators=separators, default=default, sort_keys=sort_keys,
>           **kw).encode(obj)
                  ^^^^^^^^^^^

/usr/lib/python3.12/json/__init__.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cd79820>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.
    
        >>> from json.encoder import JSONEncoder
        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'
    
        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, str):
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
>       chunks = self.iterencode(o, _one_shot=True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cd79820>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537143%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
_one_shot = True

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.
    
        For example::
    
            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)
    
        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
    
        def floatstr(o, allow_nan=self.allow_nan,
                _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
            # Check for specials.  Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on the
            # internals.
    
            if o != o:
                text = 'NaN'
            elif o == _inf:
                text = 'Infinity'
            elif o == _neginf:
                text = '-Infinity'
            else:
                return _repr(o)
    
            if not allow_nan:
                raise ValueError(
                    "Out of range float values are not JSON compliant: " +
                    repr(o))
    
            return text
    
    
        if (_one_shot and c_make_encoder is not None
                and self.indent is None):
            _iterencode = c_make_encoder(
                markers, self.default, _encoder, self.indent,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, self.allow_nan)
        else:
            _iterencode = _make_iterencode(
                markers, self.default, _encoder, self.indent, floatstr,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, _one_shot)
>       return _iterencode(o, 0)
               ^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cd79820>
o = b'username=test_oauth_1771092537143%40example.com&password=SecurePassword123%21'

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type bytes is not JSON serializable

/usr/lib/python3.12/json/encoder.py:180: TypeError
---------------------------- Captured stdout setup -----------------------------
DEBUG AUTH: create_access_token return type: <class 'str'> value: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIyODk2ZmVhNC1jZmI0LTQ5NGEtOGZmMy1iNzM5NGZhNzRjYzgiLCJleHAiOjE3NzEwOTYxMzcsInR5cGUiOiJhY2Nlc3MifQ.K8xpqb-kCJG1ipYu5eaKwL8txPI2aMLHQU1r2VEctG4
{"timestamp": "2026-02-14T18:08:57.530049+00:00", "level": "CRITICAL", "logger": "VoiceNote", "message": "Unhandled exception: Object of type bytes is not JSON serializable", "filename": "main.py", "funcName": "generic_exception_handler", "lineno": 126, "pathname": "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/app/main.py", "traceback": true}
------------------------------ Captured log setup ------------------------------
CRITICAL VoiceNote:main.py:126 Unhandled exception: Object of type bytes is not JSON serializable
____________________ ERROR at setup of test_connect_notion _____________________

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd80360>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        # Starts customization
        response_awaited = False
        async with AsyncExitStack() as request_stack:
            scope["fastapi_inner_astack"] = request_stack
            async with AsyncExitStack() as function_stack:
                scope["fastapi_function_astack"] = function_stack
>               response = await f(request)
                           ^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/fastapi/routing.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2cdbaff0>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        file_stack = request.scope.get("fastapi_middleware_astack")
        assert isinstance(file_stack, AsyncExitStack), (
            "fastapi_middleware_astack not found in request scope"
        )
    
        # Extract endpoint context for error messages
        endpoint_ctx = (
            _extract_endpoint_context(dependant.call)
            if dependant.call
            else EndpointContext()
        )
    
        if dependant.path:
            # For mounted sub-apps, include the mount path prefix
            mount_path = request.scope.get("root_path", "").rstrip("/")
            endpoint_ctx["path"] = f"{request.method} {mount_path}{dependant.path}"
    
        # Read body and auto-close files
        try:
            body: Any = None
            if body_field:
                if is_body_form:
                    body = await request.form()
                    file_stack.push_async_callback(body.close)
                else:
                    body_bytes = await request.body()
                    if body_bytes:
                        json_body: Any = Undefined
                        content_type_value = request.headers.get("content-type")
                        if not content_type_value:
                            json_body = await request.json()
                        else:
                            message = email.message.Message()
                            message["content-type"] = content_type_value
                            if message.get_content_maintype() == "application":
                                subtype = message.get_content_subtype()
                                if subtype == "json" or subtype.endswith("+json"):
                                    json_body = await request.json()
                        if json_body != Undefined:
                            body = json_body
                        else:
                            body = body_bytes
        except json.JSONDecodeError as e:
            validation_error = RequestValidationError(
                [
                    {
                        "type": "json_invalid",
                        "loc": ("body", e.pos),
                        "msg": "JSON decode error",
                        "input": {},
                        "ctx": {"error": e.msg},
                    }
                ],
                body=e.doc,
                endpoint_ctx=endpoint_ctx,
            )
            raise validation_error from e
        except HTTPException:
            # If a middleware raises an HTTPException, it should be raised again
            raise
        except Exception as e:
            http_error = HTTPException(
                status_code=400, detail="There was an error parsing the body"
            )
            raise http_error from e
    
        # Solve dependencies and run path operation function, auto-closing dependencies
        errors: list[Any] = []
        async_exit_stack = request.scope.get("fastapi_inner_astack")
        assert isinstance(async_exit_stack, AsyncExitStack), (
            "fastapi_inner_astack not found in request scope"
        )
        solved_result = await solve_dependencies(
            request=request,
            dependant=dependant,
            body=body,
            dependency_overrides_provider=dependency_overrides_provider,
            async_exit_stack=async_exit_stack,
            embed_body_fields=embed_body_fields,
        )
        errors = solved_result.errors
        if not errors:
            raw_response = await run_endpoint_function(
                dependant=dependant,
                values=solved_result.values,
                is_coroutine=is_coroutine,
            )
            if isinstance(raw_response, Response):
                if raw_response.background is None:
                    raw_response.background = solved_result.background_tasks
                response = raw_response
            else:
                response_args: dict[str, Any] = {
                    "background": solved_result.background_tasks
                }
                # If status_code was set, use it, otherwise use the default from the
                # response class, in the case of redirect it's 307
                current_status_code = (
                    status_code if status_code else solved_result.response.status_code
                )
                if current_status_code is not None:
                    response_args["status_code"] = current_status_code
                if solved_result.response.status_code:
                    response_args["status_code"] = solved_result.response.status_code
                content = await serialize_response(
                    field=response_field,
                    response_content=raw_response,
                    include=response_model_include,
                    exclude=response_model_exclude,
                    by_alias=response_model_by_alias,
                    exclude_unset=response_model_exclude_unset,
                    exclude_defaults=response_model_exclude_defaults,
                    exclude_none=response_model_exclude_none,
                    is_coroutine=is_coroutine,
                    endpoint_ctx=endpoint_ctx,
                )
                response = actual_response_class(content, **response_args)
                if not is_body_allowed_for_status_code(response.status_code):
                    response.body = b""
                response.headers.raw.extend(solved_result.response.headers.raw)
        if errors:
            validation_error = RequestValidationError(
                errors, body=body, endpoint_ctx=endpoint_ctx
            )
>           raise validation_error
E           fastapi.exceptions.RequestValidationError: 1 validation error:
E             {'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePassword123%21'}
E           
E             File "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/venv/lib/python3.12/site-packages/slowapi/extension.py", line 109, in login_user
E               POST /api/v1/users/login

venv/lib/python3.12/site-packages/fastapi/routing.py:397: RequestValidationError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>

    @pytest.fixture
    def auth_context(client):
        """Get authentication context (token and user info) for tests"""
        timestamp = int(1000 * time.time()) # increased resolution
        email = f"test_oauth_{timestamp}@example.com"
        password = "SecurePassword123!"
    
        # Register
        client.post("/api/v1/users/register", json={
            "email": email,
            "password": password,
            "name": f"Test OAuth User {timestamp}",
            "device_id": f"test-device-{timestamp}",
            "device_model": "Pytest CI"
        })
    
        # Login
>       login_response = client.post("/api/v1/users/login", data={
            "username": email,
            "password": password
        })

tests/enterprise/test_b2b_oauth.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
url = '/api/v1/users/login'

    def post(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
>       return super().post(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
url = '/api/v1/users/login'

    def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/httpx/_client.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(  # type: ignore[override]
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        if timeout is not httpx.USE_CLIENT_DEFAULT:
            warnings.warn(
                "You should not use the 'timeout' argument with the TestClient. "
                "See https://github.com/Kludex/starlette/issues/1108 for more information.",
                DeprecationWarning,
            )
        url = self._merge_url(url)
>       return super().request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = client.send(request, ...)
        ```
    
        See `Client.build_request()`, `Client.send()` and
        [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
        if cookies is not None:
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `Client.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

venv/lib/python3.12/site-packages/httpx/_client.py:914: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
auth = <httpx.Auth object at 0x73ce2cd5baa0>, follow_redirects = True
history = []

    def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.sync_auth_flow(request)
        try:
            request = next(auth_flow)
    
            while True:
>               response = self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

venv/lib/python3.12/site-packages/httpx/_client.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
follow_redirects = True, history = []

    def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                hook(request)
    
>           response = self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cd5bec0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, SyncByteStream):
            raise RuntimeError(
                "Attempted to send an async request with a sync Client instance."
            )
    
        with request_context(request=request):
>           response = transport.handle_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2cd5bef0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
                portal.call(self.app, scope, receive, send)
        except BaseException as exc:
            if self.raise_server_exceptions:
>               raise exc

venv/lib/python3.12/site-packages/starlette/testclient.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2cd5bef0>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
>               portal.call(self.app, scope, receive, send)

venv/lib/python3.12/site-packages/starlette/testclient.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2cdb9880>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce2c9c7d80>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2c9c7b00>)

    def call(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        *args: Unpack[PosArgsT],
    ) -> T_Retval:
        """
        Call the given function in the event loop thread.
    
        If the callable returns a coroutine object, it is awaited on.
    
        :param func: any callable
        :raises RuntimeError: if the portal is not running or if this method is called
            from within the event loop thread
    
        """
>       return cast(T_Retval, self.start_task_soon(func, *args).result())
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None, timeout = None

    def result(self, timeout=None):
        """Return the result of the call that the future represents.
    
        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.
    
        Returns:
            The result of the call that the future represents.
    
        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
        try:
            with self._condition:
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
                    return self.__get_result()
    
                self._condition.wait(timeout)
    
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
>                   return self.__get_result()
                           ^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/concurrent/futures/_base.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None

    def __get_result(self):
        if self._exception:
            try:
>               raise self._exception

/usr/lib/python3.12/concurrent/futures/_base.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2cdb9880>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce2c9c7d80>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2c9c7b00>)
kwargs = {}, future = <Future at 0x73ce2cdb8fb0 state=finished raised TypeError>

    async def _call_func(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        args: tuple[Unpack[PosArgsT]],
        kwargs: dict[str, Any],
        future: Future[T_Retval],
    ) -> None:
        def callback(f: Future[T_Retval]) -> None:
            if f.cancelled():
                if self._event_loop_thread_id == get_ident():
                    scope.cancel("the future was cancelled")
                elif self._event_loop_thread_id is not None:
                    self.call(scope.cancel, "the future was cancelled")
    
        try:
            retval_or_awaitable = func(*args, **kwargs)
            if isawaitable(retval_or_awaitable):
                with CancelScope() as scope:
                    future.add_done_callback(callback)
>                   retval = await retval_or_awaitable
                             ^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2c9c7d80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2c9c7b00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/applications.py:1135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2c9c7d80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2c9c7b00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/applications.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2c9c7d80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2c9c7b00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2c9c7d80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2c9c7b00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2c9c7d80>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2cd82b60>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
>       with recv_stream, send_stream, collapse_excgroups():

venv/lib/python3.12/site-packages/starlette/middleware/base.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x73ce2cdbb410>
typ = <class 'ExceptionGroup'>
value = ExceptionGroup('unhandled errors in a TaskGroup', [TypeError('Object of type bytes is not JSON serializable')])
traceback = <traceback object at 0x73ce2c44d000>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                try:
                    raise RuntimeError("generator didn't stop")
                finally:
                    self.gen.close()
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(value)

/usr/lib/python3.12/contextlib.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextmanager
    def collapse_excgroups() -> Generator[None, None, None]:
        try:
            yield
        except BaseException as exc:
            if has_exceptiongroups:  # pragma: no cover
                while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:
                    exc = exc.exceptions[0]
    
>           raise exc

venv/lib/python3.12/site-packages/starlette/_utils.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2c9c7d80>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2cd82b60>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
        with recv_stream, send_stream, collapse_excgroups():
            async with anyio.create_task_group() as task_group:
>               response = await self.dispatch_func(request, call_next)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/middleware/base.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
request = <starlette.middleware.base._CachedRequest object at 0x73ce2cdb95e0>
call_next = <function BaseHTTPMiddleware.__call__.<locals>.call_next at 0x73ce2cd83a60>

    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
    
        # Pass through check for health/metrics endpoints
        if request.url.path in ["/", "/health", "/metrics", "/docs", "/openapi.json"]:
            return await call_next(request)
    
        # 1. Capture User ID and Geolocation
        user_id = getattr(request.state, "user_id", None)
        if not user_id:
            user_id = request.headers.get("X-User-ID", "anonymous")
    
        gps_header = request.headers.get("x-gps-coords") or request.headers.get("X-GPS-Coords")
    
        corporate_wallet_id = None
    
        # Token extraction for early auth
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                user_id = payload.get("sub")
                request.state.user_id = user_id
            except Exception as e:
                JLogger.debug("Middleware: Token decode failed", error=str(e))
    
        # COST ESTIMATION
        cost_map = {
            "/api/v1/notes": 1,
            "/api/v1/transcribe": 10,
            "/api/v1/ai/analyze": 5,
        }
        estimated_cost = 0
        for path, cost in cost_map.items():
            if path in request.url.path:
                estimated_cost = cost
                break
    
        db = None
        try:
            if user_id != "anonymous" and (gps_header or estimated_cost > 0):
                db = SessionLocal()
                user = db.query(models.User).filter(models.User.id == user_id).first()
                request.state.user = user
    
                if user and user.org_id and gps_header:
                    try:
                        lat_str, lon_str = gps_header.split(",")
                        user_lat, user_lon = float(lat_str), float(lon_str)
                        locations = (
                            db.query(models.WorkLocation)
                            .filter(models.WorkLocation.org_id == user.org_id)
                            .all()
                        )
                        for loc in locations:
                            dist = calculate_distance(user_lat, user_lon, loc.latitude, loc.longitude)
                            # Use config minimum radius if loc.radius is too small (GPS Drift)
                            effective_radius = max(loc.radius, location_config.DEFAULT_GEOFENCE_RADIUS)
                            if dist <= effective_radius:
                                org = db.query(models.Organization).filter(models.Organization.id == user.org_id).first()
                                if org:
                                    corporate_wallet_id = org.corporate_wallet_id
                                    JLogger.info("Middleware: Within geofence, corporate wallet selected", wallet=corporate_wallet_id)
                                break
                    except Exception as e:
                        JLogger.error("Middleware: Geofence error", error=str(e))
    
                if estimated_cost > 0:
                    # Premium users get free notes processing
                    if user and user.tier == models.SubscriptionTier.PREMIUM and "/api/v1/notes" in request.url.path:
                        estimated_cost = 0
    
                    if estimated_cost > 0:
                        billing = BillingService(db)
                        target_wallet = corporate_wallet_id or user_id
                        if not billing.check_balance(target_wallet, estimated_cost, for_update=True):
                            return JSONResponse(
                                status_code=402,
                                content={"detail": f"Payment Required: balance depleted."},
                            )
    
>           response = await call_next(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

app/api/middleware/usage.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.middleware.base._CachedRequest object at 0x73ce2cdb95e0>

    async def call_next(request: Request) -> Response:
        async def receive_or_disconnect() -> Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(wrapped_receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def send_no_error(message: Message) -> None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -> None:
            nonlocal app_exc
    
            with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(coro)
    
        try:
            message = await recv_stream.receive()
            info = message.get("info", None)
            if message["type"] == "http.response.debug" and info is not None:
                message = await recv_stream.receive()
        except anyio.EndOfStream:
            if app_exc is not None:
                nonlocal exception_already_raised
                exception_already_raised = True
                # Prevent `anyio.EndOfStream` from polluting app exception context.
                # If both cause and context are None then the context is suppressed
                # and `anyio.EndOfStream` is not present in the exception traceback.
                # If exception cause is not None then it is propagated with
                # reraising here.
                # If exception has no cause but has context set then the context is
                # propagated as a cause with the reraise. This is necessary in order
                # to prevent `anyio.EndOfStream` from polluting the exception
                # context.
>               raise app_exc from app_exc.__cause__ or app_exc.__context__

venv/lib/python3.12/site-packages/starlette/middleware/base.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def coro() -> None:
        nonlocal app_exc
    
        with send_stream:
            try:
>               await self.app(scope, receive_or_disconnect, send_no_error)

venv/lib/python3.12/site-packages/starlette/middleware/base.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2cd83920>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
            await self.app(scope, receive, send_wrapper)
        except Exception as exc:
>           raise exc

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2cd83920>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
>           await self.app(scope, receive, send_wrapper)

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipMiddleware object at 0x73ce2e0dda00>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2cd83e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":  # pragma: no cover
            await self.app(scope, receive, send)
            return
    
        headers = Headers(scope=scope)
        responder: ASGIApp
        if "gzip" in headers.get("Accept-Encoding", ""):
            responder = GZipResponder(self.app, self.minimum_size, compresslevel=self.compresslevel)
        else:
            responder = IdentityResponder(self.app, self.minimum_size)
    
>       await responder(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdbaa50>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2cd83e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        with self.gzip_buffer, self.gzip_file:
>           await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdbaa50>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2cd83e20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        self.send = send
>       await self.app(scope, receive, self.send_with_compression)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x73ce2ddf38c0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdbaa50>>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdbaa50>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdbaa50>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.middleware.asyncexitstack.AsyncExitStackMiddleware object at 0x73ce2ddf3890>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        async with AsyncExitStack() as stack:
            scope[self.context_name] = stack
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = APIRoute(path='/api/v1/users/login', name='login_user', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse("Method Not Allowed", status_code=405, headers=headers)
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            # Starts customization
            response_awaited = False
            async with AsyncExitStack() as request_stack:
                scope["fastapi_inner_astack"] = request_stack
                async with AsyncExitStack() as function_stack:
                    scope["fastapi_function_astack"] = function_stack
                    response = await f(request)
                await response(scope, receive, send)
                # Continues customization
                response_awaited = True
            if not response_awaited:
                raise FastAPIError(
                    "Response not awaited. There's a high chance that the "
                    "application code is raising an exception and a dependency with yield "
                    "has a block with a bare except, or a block with except Exception, "
                    "and is not raising the exception again. Read more about it in the "
                    "docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except"
                )
    
        # Same as in Starlette
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/routing.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2cd83d80>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2cd83600>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
                raise exc
    
            if response_started:
                raise RuntimeError("Caught handled exception, but response already started.") from exc
    
            if is_async_callable(handler):
>               response = await handler(conn, exc)
                           ^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2cdbaff0>
exc = RequestValidationError([{'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary...t to extract fields from', 'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePassword123%21'}])

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        """Standardize Pydantic validation errors."""
>       return JSONResponse(
            status_code=400,
            content={
                "error": "Validation failed",
                "code": "VALIDATION_ERROR",
                "detail": exc.errors()
            },
        )

app/main.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cdbb530>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
>       super().__init__(content, status_code, headers, media_type, background)

venv/lib/python3.12/site-packages/starlette/responses.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cdbb530>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
>       self.body = self.render(content)
                    ^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/responses.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cdbb530>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def render(self, content: Any) -> bytes:
>       return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")

venv/lib/python3.12/site-packages/starlette/responses.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
skipkeys = False, ensure_ascii = False, check_circular = True, allow_nan = False
cls = <class 'json.encoder.JSONEncoder'>, indent = None, separators = (',', ':')
default = None

    def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
            allow_nan=True, cls=None, indent=None, separators=None,
            default=None, sort_keys=False, **kw):
        """Serialize ``obj`` to a JSON formatted ``str``.
    
        If ``skipkeys`` is true then ``dict`` keys that are not basic types
        (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
        instead of raising a ``TypeError``.
    
        If ``ensure_ascii`` is false, then the return value can contain non-ASCII
        characters if they appear in strings contained in ``obj``. Otherwise, all
        such characters are escaped in JSON strings.
    
        If ``check_circular`` is false, then the circular reference check
        for container types will be skipped and a circular reference will
        result in an ``RecursionError`` (or worse).
    
        If ``allow_nan`` is false, then it will be a ``ValueError`` to
        serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
        strict compliance of the JSON specification, instead of using the
        JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).
    
        If ``indent`` is a non-negative integer, then JSON array elements and
        object members will be pretty-printed with that indent level. An indent
        level of 0 will only insert newlines. ``None`` is the most compact
        representation.
    
        If specified, ``separators`` should be an ``(item_separator, key_separator)``
        tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
        ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
        you should specify ``(',', ':')`` to eliminate whitespace.
    
        ``default(obj)`` is a function that should return a serializable version
        of obj or raise TypeError. The default simply raises TypeError.
    
        If *sort_keys* is true (default: ``False``), then the output of
        dictionaries will be sorted by key.
    
        To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
        ``.default()`` method to serialize additional types), specify it with
        the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
    
        """
        # cached encoder
        if (not skipkeys and ensure_ascii and
            check_circular and allow_nan and
            cls is None and indent is None and separators is None and
            default is None and not sort_keys and not kw):
            return _default_encoder.encode(obj)
        if cls is None:
            cls = JSONEncoder
        return cls(
            skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, allow_nan=allow_nan, indent=indent,
            separators=separators, default=default, sort_keys=sort_keys,
>           **kw).encode(obj)
                  ^^^^^^^^^^^

/usr/lib/python3.12/json/__init__.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cdbb590>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.
    
        >>> from json.encoder import JSONEncoder
        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'
    
        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, str):
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
>       chunks = self.iterencode(o, _one_shot=True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cdbb590>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092537883%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
_one_shot = True

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.
    
        For example::
    
            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)
    
        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
    
        def floatstr(o, allow_nan=self.allow_nan,
                _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
            # Check for specials.  Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on the
            # internals.
    
            if o != o:
                text = 'NaN'
            elif o == _inf:
                text = 'Infinity'
            elif o == _neginf:
                text = '-Infinity'
            else:
                return _repr(o)
    
            if not allow_nan:
                raise ValueError(
                    "Out of range float values are not JSON compliant: " +
                    repr(o))
    
            return text
    
    
        if (_one_shot and c_make_encoder is not None
                and self.indent is None):
            _iterencode = c_make_encoder(
                markers, self.default, _encoder, self.indent,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, self.allow_nan)
        else:
            _iterencode = _make_iterencode(
                markers, self.default, _encoder, self.indent, floatstr,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, _one_shot)
>       return _iterencode(o, 0)
               ^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cdbb590>
o = b'username=test_oauth_1771092537883%40example.com&password=SecurePassword123%21'

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type bytes is not JSON serializable

/usr/lib/python3.12/json/encoder.py:180: TypeError
---------------------------- Captured stdout setup -----------------------------
DEBUG AUTH: create_access_token return type: <class 'str'> value: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhODM3YTBkNS0xMzNiLTQ4NjItOTEyMi0zNzMyODYyMjI0NTAiLCJleHAiOjE3NzEwOTYxMzgsInR5cGUiOiJhY2Nlc3MifQ.kxxFHyn_egnwRBKItZrZ8qM9AYxYERD7UN8h1OUFzzs
{"timestamp": "2026-02-14T18:08:58.263428+00:00", "level": "CRITICAL", "logger": "VoiceNote", "message": "Unhandled exception: Object of type bytes is not JSON serializable", "filename": "main.py", "funcName": "generic_exception_handler", "lineno": 126, "pathname": "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/app/main.py", "traceback": true}
------------------------------ Captured log setup ------------------------------
CRITICAL VoiceNote:main.py:126 Unhandled exception: Object of type bytes is not JSON serializable
________________ ERROR at setup of test_disconnect_integration _________________

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2de0>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        # Starts customization
        response_awaited = False
        async with AsyncExitStack() as request_stack:
            scope["fastapi_inner_astack"] = request_stack
            async with AsyncExitStack() as function_stack:
                scope["fastapi_function_astack"] = function_stack
>               response = await f(request)
                           ^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/fastapi/routing.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2cddeb70>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        file_stack = request.scope.get("fastapi_middleware_astack")
        assert isinstance(file_stack, AsyncExitStack), (
            "fastapi_middleware_astack not found in request scope"
        )
    
        # Extract endpoint context for error messages
        endpoint_ctx = (
            _extract_endpoint_context(dependant.call)
            if dependant.call
            else EndpointContext()
        )
    
        if dependant.path:
            # For mounted sub-apps, include the mount path prefix
            mount_path = request.scope.get("root_path", "").rstrip("/")
            endpoint_ctx["path"] = f"{request.method} {mount_path}{dependant.path}"
    
        # Read body and auto-close files
        try:
            body: Any = None
            if body_field:
                if is_body_form:
                    body = await request.form()
                    file_stack.push_async_callback(body.close)
                else:
                    body_bytes = await request.body()
                    if body_bytes:
                        json_body: Any = Undefined
                        content_type_value = request.headers.get("content-type")
                        if not content_type_value:
                            json_body = await request.json()
                        else:
                            message = email.message.Message()
                            message["content-type"] = content_type_value
                            if message.get_content_maintype() == "application":
                                subtype = message.get_content_subtype()
                                if subtype == "json" or subtype.endswith("+json"):
                                    json_body = await request.json()
                        if json_body != Undefined:
                            body = json_body
                        else:
                            body = body_bytes
        except json.JSONDecodeError as e:
            validation_error = RequestValidationError(
                [
                    {
                        "type": "json_invalid",
                        "loc": ("body", e.pos),
                        "msg": "JSON decode error",
                        "input": {},
                        "ctx": {"error": e.msg},
                    }
                ],
                body=e.doc,
                endpoint_ctx=endpoint_ctx,
            )
            raise validation_error from e
        except HTTPException:
            # If a middleware raises an HTTPException, it should be raised again
            raise
        except Exception as e:
            http_error = HTTPException(
                status_code=400, detail="There was an error parsing the body"
            )
            raise http_error from e
    
        # Solve dependencies and run path operation function, auto-closing dependencies
        errors: list[Any] = []
        async_exit_stack = request.scope.get("fastapi_inner_astack")
        assert isinstance(async_exit_stack, AsyncExitStack), (
            "fastapi_inner_astack not found in request scope"
        )
        solved_result = await solve_dependencies(
            request=request,
            dependant=dependant,
            body=body,
            dependency_overrides_provider=dependency_overrides_provider,
            async_exit_stack=async_exit_stack,
            embed_body_fields=embed_body_fields,
        )
        errors = solved_result.errors
        if not errors:
            raw_response = await run_endpoint_function(
                dependant=dependant,
                values=solved_result.values,
                is_coroutine=is_coroutine,
            )
            if isinstance(raw_response, Response):
                if raw_response.background is None:
                    raw_response.background = solved_result.background_tasks
                response = raw_response
            else:
                response_args: dict[str, Any] = {
                    "background": solved_result.background_tasks
                }
                # If status_code was set, use it, otherwise use the default from the
                # response class, in the case of redirect it's 307
                current_status_code = (
                    status_code if status_code else solved_result.response.status_code
                )
                if current_status_code is not None:
                    response_args["status_code"] = current_status_code
                if solved_result.response.status_code:
                    response_args["status_code"] = solved_result.response.status_code
                content = await serialize_response(
                    field=response_field,
                    response_content=raw_response,
                    include=response_model_include,
                    exclude=response_model_exclude,
                    by_alias=response_model_by_alias,
                    exclude_unset=response_model_exclude_unset,
                    exclude_defaults=response_model_exclude_defaults,
                    exclude_none=response_model_exclude_none,
                    is_coroutine=is_coroutine,
                    endpoint_ctx=endpoint_ctx,
                )
                response = actual_response_class(content, **response_args)
                if not is_body_allowed_for_status_code(response.status_code):
                    response.body = b""
                response.headers.raw.extend(solved_result.response.headers.raw)
        if errors:
            validation_error = RequestValidationError(
                errors, body=body, endpoint_ctx=endpoint_ctx
            )
>           raise validation_error
E           fastapi.exceptions.RequestValidationError: 1 validation error:
E             {'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePassword123%21'}
E           
E             File "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/venv/lib/python3.12/site-packages/slowapi/extension.py", line 109, in login_user
E               POST /api/v1/users/login

venv/lib/python3.12/site-packages/fastapi/routing.py:397: RequestValidationError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x73ce2cdd3320>

    @pytest.fixture
    def auth_context(client):
        """Get authentication context (token and user info) for tests"""
        timestamp = int(1000 * time.time()) # increased resolution
        email = f"test_oauth_{timestamp}@example.com"
        password = "SecurePassword123!"
    
        # Register
        client.post("/api/v1/users/register", json={
            "email": email,
            "password": password,
            "name": f"Test OAuth User {timestamp}",
            "device_id": f"test-device-{timestamp}",
            "device_model": "Pytest CI"
        })
    
        # Login
>       login_response = client.post("/api/v1/users/login", data={
            "username": email,
            "password": password
        })

tests/enterprise/test_b2b_oauth.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
url = '/api/v1/users/login'

    def post(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
>       return super().post(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
url = '/api/v1/users/login'

    def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/httpx/_client.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(  # type: ignore[override]
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        if timeout is not httpx.USE_CLIENT_DEFAULT:
            warnings.warn(
                "You should not use the 'timeout' argument with the TestClient. "
                "See https://github.com/Kludex/starlette/issues/1108 for more information.",
                DeprecationWarning,
            )
        url = self._merge_url(url)
>       return super().request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

venv/lib/python3.12/site-packages/starlette/testclient.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
method = 'POST', url = URL('http://testserver/api/v1/users/login')

    def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = client.send(request, ...)
        ```
    
        See `Client.build_request()`, `Client.send()` and
        [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
        if cookies is not None:
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `Client.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

venv/lib/python3.12/site-packages/httpx/_client.py:914: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
auth = <httpx.Auth object at 0x73ce2f160380>, follow_redirects = True
history = []

    def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.sync_auth_flow(request)
        try:
            request = next(auth_flow)
    
            while True:
>               response = self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

venv/lib/python3.12/site-packages/httpx/_client.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
request = <Request('POST', 'http://testserver/api/v1/users/login')>
follow_redirects = True, history = []

    def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                hook(request)
    
>           response = self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient.TestClient object at 0x73ce2cdd3320>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, SyncByteStream):
            raise RuntimeError(
                "Attempted to send an async request with a sync Client instance."
            )
    
        with request_context(request=request):
>           response = transport.handle_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/httpx/_client.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2cdd0c20>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
                portal.call(self.app, scope, receive, send)
        except BaseException as exc:
            if self.raise_server_exceptions:
>               raise exc

venv/lib/python3.12/site-packages/starlette/testclient.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.testclient._TestClientTransport object at 0x73ce2cdd0c20>
request = <Request('POST', 'http://testserver/api/v1/users/login')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
>               portal.call(self.app, scope, receive, send)

venv/lib/python3.12/site-packages/starlette/testclient.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2cdd33b0>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce2cd80b80>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2cd83740>)

    def call(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        *args: Unpack[PosArgsT],
    ) -> T_Retval:
        """
        Call the given function in the event loop thread.
    
        If the callable returns a coroutine object, it is awaited on.
    
        :param func: any callable
        :raises RuntimeError: if the portal is not running or if this method is called
            from within the event loop thread
    
        """
>       return cast(T_Retval, self.start_task_soon(func, *args).result())
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None, timeout = None

    def result(self, timeout=None):
        """Return the result of the call that the future represents.
    
        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.
    
        Returns:
            The result of the call that the future represents.
    
        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
        try:
            with self._condition:
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
                    return self.__get_result()
    
                self._condition.wait(timeout)
    
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
>                   return self.__get_result()
                           ^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/concurrent/futures/_base.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None

    def __get_result(self):
        if self._exception:
            try:
>               raise self._exception

/usr/lib/python3.12/concurrent/futures/_base.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio.from_thread.BlockingPortal object at 0x73ce2cdd33b0>
func = <fastapi.applications.FastAPI object at 0x73ce2df89850>
args = ({'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <functi...st.<locals>.receive at 0x73ce2cd80b80>, <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2cd83740>)
kwargs = {}, future = <Future at 0x73ce2cdd3350 state=finished raised TypeError>

    async def _call_func(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        args: tuple[Unpack[PosArgsT]],
        kwargs: dict[str, Any],
        future: Future[T_Retval],
    ) -> None:
        def callback(f: Future[T_Retval]) -> None:
            if f.cancelled():
                if self._event_loop_thread_id == get_ident():
                    scope.cancel("the future was cancelled")
                elif self._event_loop_thread_id is not None:
                    self.call(scope.cancel, "the future was cancelled")
    
        try:
            retval_or_awaitable = func(*args, **kwargs)
            if isawaitable(retval_or_awaitable):
                with CancelScope() as scope:
                    future.add_done_callback(callback)
>                   retval = await retval_or_awaitable
                             ^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/anyio/from_thread.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2cd80b80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2cd83740>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/applications.py:1135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x73ce2df89850>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2cd80b80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2cd83740>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/applications.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2cd80b80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2cd83740>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x73ce2dc240e0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2cd80b80>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x73ce2cd83740>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

venv/lib/python3.12/site-packages/starlette/middleware/errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2cd80b80>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2c2c22a0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
>       with recv_stream, send_stream, collapse_excgroups():

venv/lib/python3.12/site-packages/starlette/middleware/base.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x73ce2cddc290>
typ = <class 'ExceptionGroup'>
value = ExceptionGroup('unhandled errors in a TaskGroup', [TypeError('Object of type bytes is not JSON serializable')])
traceback = <traceback object at 0x73ce2d0dcb00>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                try:
                    raise RuntimeError("generator didn't stop")
                finally:
                    self.gen.close()
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(value)

/usr/lib/python3.12/contextlib.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextmanager
    def collapse_excgroups() -> Generator[None, None, None]:
        try:
            yield
        except BaseException as exc:
            if has_exceptiongroups:  # pragma: no cover
                while isinstance(exc, BaseExceptionGroup) and len(exc.exceptions) == 1:
                    exc = exc.exceptions[0]
    
>           raise exc

venv/lib/python3.12/site-packages/starlette/_utils.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x73ce2cd80b80>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x73ce2c2c22a0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        request = _CachedRequest(scope, receive)
        wrapped_receive = request.wrapped_receive
        response_sent = anyio.Event()
        app_exc: Exception | None = None
        exception_already_raised = False
    
        async def call_next(request: Request) -> Response:
            async def receive_or_disconnect() -> Message:
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                async with anyio.create_task_group() as task_group:
    
                    async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                        result = await func()
                        task_group.cancel_scope.cancel()
                        return result
    
                    task_group.start_soon(wrap, response_sent.wait)
                    message = await wrap(wrapped_receive)
    
                if response_sent.is_set():
                    return {"type": "http.disconnect"}
    
                return message
    
            async def send_no_error(message: Message) -> None:
                try:
                    await send_stream.send(message)
                except anyio.BrokenResourceError:
                    # recv_stream has been closed, i.e. response_sent has been set.
                    return
    
            async def coro() -> None:
                nonlocal app_exc
    
                with send_stream:
                    try:
                        await self.app(scope, receive_or_disconnect, send_no_error)
                    except Exception as exc:
                        app_exc = exc
    
            task_group.start_soon(coro)
    
            try:
                message = await recv_stream.receive()
                info = message.get("info", None)
                if message["type"] == "http.response.debug" and info is not None:
                    message = await recv_stream.receive()
            except anyio.EndOfStream:
                if app_exc is not None:
                    nonlocal exception_already_raised
                    exception_already_raised = True
                    # Prevent `anyio.EndOfStream` from polluting app exception context.
                    # If both cause and context are None then the context is suppressed
                    # and `anyio.EndOfStream` is not present in the exception traceback.
                    # If exception cause is not None then it is propagated with
                    # reraising here.
                    # If exception has no cause but has context set then the context is
                    # propagated as a cause with the reraise. This is necessary in order
                    # to prevent `anyio.EndOfStream` from polluting the exception
                    # context.
                    raise app_exc from app_exc.__cause__ or app_exc.__context__
                raise RuntimeError("No response returned.")
    
            assert message["type"] == "http.response.start"
    
            async def body_stream() -> BodyStreamGenerator:
                async for message in recv_stream:
                    if message["type"] == "http.response.pathsend":
                        yield message
                        break
                    assert message["type"] == "http.response.body", f"Unexpected message: {message}"
                    body = message.get("body", b"")
                    if body:
                        yield body
                    if not message.get("more_body", False):
                        break
    
            response = _StreamingResponse(status_code=message["status"], content=body_stream(), info=info)
            response.raw_headers = message["headers"]
            return response
    
        streams: anyio.create_memory_object_stream[Message] = anyio.create_memory_object_stream()
        send_stream, recv_stream = streams
        with recv_stream, send_stream, collapse_excgroups():
            async with anyio.create_task_group() as task_group:
>               response = await self.dispatch_func(request, call_next)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/middleware/base.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.api.middleware.usage.UsageTrackingMiddleware object at 0x73ce2dc240b0>
request = <starlette.middleware.base._CachedRequest object at 0x73ce2cdde150>
call_next = <function BaseHTTPMiddleware.__call__.<locals>.call_next at 0x73ce2c2c2520>

    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
    
        # Pass through check for health/metrics endpoints
        if request.url.path in ["/", "/health", "/metrics", "/docs", "/openapi.json"]:
            return await call_next(request)
    
        # 1. Capture User ID and Geolocation
        user_id = getattr(request.state, "user_id", None)
        if not user_id:
            user_id = request.headers.get("X-User-ID", "anonymous")
    
        gps_header = request.headers.get("x-gps-coords") or request.headers.get("X-GPS-Coords")
    
        corporate_wallet_id = None
    
        # Token extraction for early auth
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                user_id = payload.get("sub")
                request.state.user_id = user_id
            except Exception as e:
                JLogger.debug("Middleware: Token decode failed", error=str(e))
    
        # COST ESTIMATION
        cost_map = {
            "/api/v1/notes": 1,
            "/api/v1/transcribe": 10,
            "/api/v1/ai/analyze": 5,
        }
        estimated_cost = 0
        for path, cost in cost_map.items():
            if path in request.url.path:
                estimated_cost = cost
                break
    
        db = None
        try:
            if user_id != "anonymous" and (gps_header or estimated_cost > 0):
                db = SessionLocal()
                user = db.query(models.User).filter(models.User.id == user_id).first()
                request.state.user = user
    
                if user and user.org_id and gps_header:
                    try:
                        lat_str, lon_str = gps_header.split(",")
                        user_lat, user_lon = float(lat_str), float(lon_str)
                        locations = (
                            db.query(models.WorkLocation)
                            .filter(models.WorkLocation.org_id == user.org_id)
                            .all()
                        )
                        for loc in locations:
                            dist = calculate_distance(user_lat, user_lon, loc.latitude, loc.longitude)
                            # Use config minimum radius if loc.radius is too small (GPS Drift)
                            effective_radius = max(loc.radius, location_config.DEFAULT_GEOFENCE_RADIUS)
                            if dist <= effective_radius:
                                org = db.query(models.Organization).filter(models.Organization.id == user.org_id).first()
                                if org:
                                    corporate_wallet_id = org.corporate_wallet_id
                                    JLogger.info("Middleware: Within geofence, corporate wallet selected", wallet=corporate_wallet_id)
                                break
                    except Exception as e:
                        JLogger.error("Middleware: Geofence error", error=str(e))
    
                if estimated_cost > 0:
                    # Premium users get free notes processing
                    if user and user.tier == models.SubscriptionTier.PREMIUM and "/api/v1/notes" in request.url.path:
                        estimated_cost = 0
    
                    if estimated_cost > 0:
                        billing = BillingService(db)
                        target_wallet = corporate_wallet_id or user_id
                        if not billing.check_balance(target_wallet, estimated_cost, for_update=True):
                            return JSONResponse(
                                status_code=402,
                                content={"detail": f"Payment Required: balance depleted."},
                            )
    
>           response = await call_next(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

app/api/middleware/usage.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.middleware.base._CachedRequest object at 0x73ce2cdde150>

    async def call_next(request: Request) -> Response:
        async def receive_or_disconnect() -> Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: Callable[[], Awaitable[T]]) -> T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(wrapped_receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def send_no_error(message: Message) -> None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -> None:
            nonlocal app_exc
    
            with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(coro)
    
        try:
            message = await recv_stream.receive()
            info = message.get("info", None)
            if message["type"] == "http.response.debug" and info is not None:
                message = await recv_stream.receive()
        except anyio.EndOfStream:
            if app_exc is not None:
                nonlocal exception_already_raised
                exception_already_raised = True
                # Prevent `anyio.EndOfStream` from polluting app exception context.
                # If both cause and context are None then the context is suppressed
                # and `anyio.EndOfStream` is not present in the exception traceback.
                # If exception cause is not None then it is propagated with
                # reraising here.
                # If exception has no cause but has context set then the context is
                # propagated as a cause with the reraise. This is necessary in order
                # to prevent `anyio.EndOfStream` from polluting the exception
                # context.
>               raise app_exc from app_exc.__cause__ or app_exc.__context__

venv/lib/python3.12/site-packages/starlette/middleware/base.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def coro() -> None:
        nonlocal app_exc
    
        with send_stream:
            try:
>               await self.app(scope, receive_or_disconnect, send_no_error)

venv/lib/python3.12/site-packages/starlette/middleware/base.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2c2c2980>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
            await self.app(scope, receive, send_wrapper)
        except Exception as exc:
>           raise exc

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <prometheus_fastapi_instrumentator.middleware.PrometheusInstrumentatorMiddleware object at 0x73ce2ddf38f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.send_no_error at 0x73ce2c2c2980>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
    
        request = Request(scope)
        start_time = default_timer()
    
        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            "none" if not is_templated and self.should_group_untemplated else handler
        )
    
        if not is_excluded and self.inprogress:
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()
    
        status_code = 500
        headers = []
        body = b""
        response_start_time = None
    
        # Message body collected for handlers matching body_handlers patterns.
        if any(pattern.search(handler) for pattern in self.body_handlers):
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                elif message["type"] == "http.response.body" and message["body"]:
                    nonlocal body
                    body += message["body"]
                await send(message)
    
        else:
    
            async def send_wrapper(message: Message) -> None:
                if message["type"] == "http.response.start":
                    nonlocal status_code, headers, response_start_time
                    headers = message["headers"]
                    status_code = message["status"]
                    response_start_time = default_timer()
                await send(message)
    
        try:
>           await self.app(scope, receive, send_wrapper)

venv/lib/python3.12/site-packages/prometheus_fastapi_instrumentator/middleware.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipMiddleware object at 0x73ce2e0dda00>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2c2c2f20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":  # pragma: no cover
            await self.app(scope, receive, send)
            return
    
        headers = Headers(scope=scope)
        responder: ASGIApp
        if "gzip" in headers.get("Accept-Encoding", ""):
            responder = GZipResponder(self.app, self.minimum_size, compresslevel=self.compresslevel)
        else:
            responder = IdentityResponder(self.app, self.minimum_size)
    
>       await responder(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdde9f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2c2c2f20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        with self.gzip_buffer, self.gzip_file:
>           await super().__call__(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdde9f0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function PrometheusInstrumentatorMiddleware.__call__.<locals>.send_wrapper at 0x73ce2c2c2f20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        self.send = send
>       await self.app(scope, receive, self.send_with_compression)

venv/lib/python3.12/site-packages/starlette/middleware/gzip.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x73ce2ddf38c0>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdde9f0>>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdde9f0>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <bound method IdentityResponder.send_with_compression of <starlette.middleware.gzip.GZipResponder object at 0x73ce2cdde9f0>>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.middleware.asyncexitstack.AsyncExitStackMiddleware object at 0x73ce2ddf3890>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        async with AsyncExitStack() as stack:
            scope[self.context_name] = stack
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x73ce2df8a780>
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = APIRoute(path='/api/v1/users/login', name='login_user', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse("Method Not Allowed", status_code=405, headers=headers)
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

venv/lib/python3.12/site-packages/starlette/routing.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            # Starts customization
            response_awaited = False
            async with AsyncExitStack() as request_stack:
                scope["fastapi_inner_astack"] = request_stack
                async with AsyncExitStack() as function_stack:
                    scope["fastapi_function_astack"] = function_stack
                    response = await f(request)
                await response(scope, receive, send)
                # Continues customization
                response_awaited = True
            if not response_awaited:
                raise FastAPIError(
                    "Response not awaited. There's a high chance that the "
                    "application code is raising an exception and a dependency with yield "
                    "has a block with a bare except, or a block with except Exception, "
                    "and is not raising the exception again. Read more about it in the "
                    "docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except"
                )
    
        # Same as in Starlette
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

venv/lib/python3.12/site-packages/fastapi/routing.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x73ce2df89850>, 'client': ('testclient', 50000), 'endpoint': <function login_user at 0x73ce2f135120>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function BaseHTTPMiddleware.__call__.<locals>.call_next.<locals>.receive_or_disconnect at 0x73ce2c2c2c00>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x73ce2c2c2ca0>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
                raise exc
    
            if response_started:
                raise RuntimeError("Caught handled exception, but response already started.") from exc
    
            if is_async_callable(handler):
>               response = await handler(conn, exc)
                           ^^^^^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/_exception_handler.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x73ce2cddeb70>
exc = RequestValidationError([{'type': 'model_attributes_type', 'loc': ('body',), 'msg': 'Input should be a valid dictionary...t to extract fields from', 'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePassword123%21'}])

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        """Standardize Pydantic validation errors."""
>       return JSONResponse(
            status_code=400,
            content={
                "error": "Validation failed",
                "code": "VALIDATION_ERROR",
                "detail": exc.errors()
            },
        )

app/main.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cddcaa0>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
>       super().__init__(content, status_code, headers, media_type, background)

venv/lib/python3.12/site-packages/starlette/responses.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cddcaa0>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
status_code = 400, headers = None, media_type = None, background = None

    def __init__(
        self,
        content: Any = None,
        status_code: int = 200,
        headers: Mapping[str, str] | None = None,
        media_type: str | None = None,
        background: BackgroundTask | None = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
>       self.body = self.render(content)
                    ^^^^^^^^^^^^^^^^^^^^

venv/lib/python3.12/site-packages/starlette/responses.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.responses.JSONResponse object at 0x73ce2cddcaa0>
content = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def render(self, content: Any) -> bytes:
>       return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")

venv/lib/python3.12/site-packages/starlette/responses.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
skipkeys = False, ensure_ascii = False, check_circular = True, allow_nan = False
cls = <class 'json.encoder.JSONEncoder'>, indent = None, separators = (',', ':')
default = None

    def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
            allow_nan=True, cls=None, indent=None, separators=None,
            default=None, sort_keys=False, **kw):
        """Serialize ``obj`` to a JSON formatted ``str``.
    
        If ``skipkeys`` is true then ``dict`` keys that are not basic types
        (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
        instead of raising a ``TypeError``.
    
        If ``ensure_ascii`` is false, then the return value can contain non-ASCII
        characters if they appear in strings contained in ``obj``. Otherwise, all
        such characters are escaped in JSON strings.
    
        If ``check_circular`` is false, then the circular reference check
        for container types will be skipped and a circular reference will
        result in an ``RecursionError`` (or worse).
    
        If ``allow_nan`` is false, then it will be a ``ValueError`` to
        serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
        strict compliance of the JSON specification, instead of using the
        JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).
    
        If ``indent`` is a non-negative integer, then JSON array elements and
        object members will be pretty-printed with that indent level. An indent
        level of 0 will only insert newlines. ``None`` is the most compact
        representation.
    
        If specified, ``separators`` should be an ``(item_separator, key_separator)``
        tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
        ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
        you should specify ``(',', ':')`` to eliminate whitespace.
    
        ``default(obj)`` is a function that should return a serializable version
        of obj or raise TypeError. The default simply raises TypeError.
    
        If *sort_keys* is true (default: ``False``), then the output of
        dictionaries will be sorted by key.
    
        To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
        ``.default()`` method to serialize additional types), specify it with
        the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
    
        """
        # cached encoder
        if (not skipkeys and ensure_ascii and
            check_circular and allow_nan and
            cls is None and indent is None and separators is None and
            default is None and not sort_keys and not kw):
            return _default_encoder.encode(obj)
        if cls is None:
            cls = JSONEncoder
        return cls(
            skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, allow_nan=allow_nan, indent=indent,
            separators=separators, default=default, sort_keys=sort_keys,
>           **kw).encode(obj)
                  ^^^^^^^^^^^

/usr/lib/python3.12/json/__init__.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cddc9b0>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.
    
        >>> from json.encoder import JSONEncoder
        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'
    
        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, str):
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
>       chunks = self.iterencode(o, _one_shot=True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cddc9b0>
o = {'code': 'VALIDATION_ERROR', 'detail': [{'input': b'username=test_oauth_1771092538558%40example.com&password=SecurePas... a valid dictionary or object to extract fields from', 'type': 'model_attributes_type'}], 'error': 'Validation failed'}
_one_shot = True

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.
    
        For example::
    
            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)
    
        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
    
        def floatstr(o, allow_nan=self.allow_nan,
                _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
            # Check for specials.  Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on the
            # internals.
    
            if o != o:
                text = 'NaN'
            elif o == _inf:
                text = 'Infinity'
            elif o == _neginf:
                text = '-Infinity'
            else:
                return _repr(o)
    
            if not allow_nan:
                raise ValueError(
                    "Out of range float values are not JSON compliant: " +
                    repr(o))
    
            return text
    
    
        if (_one_shot and c_make_encoder is not None
                and self.indent is None):
            _iterencode = c_make_encoder(
                markers, self.default, _encoder, self.indent,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, self.allow_nan)
        else:
            _iterencode = _make_iterencode(
                markers, self.default, _encoder, self.indent, floatstr,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, _one_shot)
>       return _iterencode(o, 0)
               ^^^^^^^^^^^^^^^^^

/usr/lib/python3.12/json/encoder.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.encoder.JSONEncoder object at 0x73ce2cddc9b0>
o = b'username=test_oauth_1771092538558%40example.com&password=SecurePassword123%21'

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type bytes is not JSON serializable

/usr/lib/python3.12/json/encoder.py:180: TypeError
---------------------------- Captured stdout setup -----------------------------
DEBUG AUTH: create_access_token return type: <class 'str'> value: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIwZmU5MDdkYi0yNWNkLTRhZGEtODg4Yy04ODFmZjg0NWViMGQiLCJleHAiOjE3NzEwOTYxMzgsInR5cGUiOiJhY2Nlc3MifQ.dLZIjvX0z4YjtsgVFNF88emmLzcgCvd4bahow9AD50w
{"timestamp": "2026-02-14T18:08:58.912554+00:00", "level": "CRITICAL", "logger": "VoiceNote", "message": "Unhandled exception: Object of type bytes is not JSON serializable", "filename": "main.py", "funcName": "generic_exception_handler", "lineno": 126, "pathname": "/home/basitdev/Me/StudioProjects/VoiceNoteAPI/app/main.py", "traceback": true}
------------------------------ Captured log setup ------------------------------
CRITICAL VoiceNote:main.py:126 Unhandled exception: Object of type bytes is not JSON serializable
=============================== warnings summary ===============================
app/api/folders.py:30
  /home/basitdev/Me/StudioProjects/VoiceNoteAPI/app/api/folders.py:30: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FolderResponse(BaseModel):

tests/enterprise/test_b2b_oauth.py::test_list_integrations_empty
tests/enterprise/test_b2b_oauth.py::test_connect_google
tests/enterprise/test_b2b_oauth.py::test_connect_notion
tests/enterprise/test_b2b_oauth.py::test_disconnect_integration
  /home/basitdev/Me/StudioProjects/VoiceNoteAPI/tests/conftest.py:195: SAWarning: Cannot correctly sort tables; there are unresolvable cycles between tables "organizations, users", which is usually caused by mutually dependent foreign key constraints.  Foreign key constraints involving these tables will not be considered; this warning may raise an error in a future release.
    for table in reversed(Base.metadata.sorted_tables):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/enterprise/test_b2b_oauth.py::test_list_integrations_empty - TypeError: Object of type bytes is not JSON serializable
ERROR tests/enterprise/test_b2b_oauth.py::test_connect_google - TypeError: Object of type bytes is not JSON serializable
ERROR tests/enterprise/test_b2b_oauth.py::test_connect_notion - TypeError: Object of type bytes is not JSON serializable
ERROR tests/enterprise/test_b2b_oauth.py::test_disconnect_integration - TypeError: Object of type bytes is not JSON serializable
======================== 5 warnings, 4 errors in 5.72s =========================
